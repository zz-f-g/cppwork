# class

---

## 9.1

introduction

---

使得结构体同时拥有数据和成员函数。但是用 ``sizeof`` 计算类的大小的时候，不会统计成员函数的内存占用。

类同样具有字节对齐的规则。

通过成员访问限定符，可以指定成员的属性是私有还是共有。只有共有属性可以被外界访问。通常把数据设定为 ``private``，把成员函数设置为 ``public``

---

类和结构体的比较：

- 在 C++ 中，将 ``struct`` 互换成 ``class``，不改变逻辑和报错警告情况。
- 缺省限定符，``struct`` 为 ``public``，``class`` 缺省为 ``private``.

---

成员函数的实现

- 体内：在 class 中给出成员函数的定义及实现过程。
- 体外：在 class 中给出定义，在 class 定义后给出实现。
    - 需要加类作用域符 ``::``

- 成员函数
- 全局函数

---

如何在类中访问和成员函数同名的全局函数？

```cpp
void test::func_sub()
{
    func(); // class function
    ::func(); // global function
}
```

==低层屏蔽高层==

同样对局部变量和全局变量也有相应的规则（只适合 C++）

```cpp
class test
{
    public:
        int a;
}
int a = 10;
int main()
{
    int a = 1;
    test t1;
    cout << a << endl;
    cout << t1::a;
    cout << ::a << endl;
    return 0;
}
```

---

成员函数的存储

类的成员函数占用函数（代码）区，每个类的每个成员函数（包括**体内**和**体外**）只占用一段空间。

好处：对所有的类的实例用的函数都是同一个，避免空间浪费。

所有类的成员函数都隐藏了 ``this`` 指针，调用时会隐含传入调用对象的地址。因此虽然所有实例在调用==同一个成员函数==，但是==成员函数中的成员变量==的值是不同的。

``this`` 指针不能写在形参列表中，但是可以在实现过程中显式访问。

---

- 类的封装性和信息隐蔽
- 类的声明和成员函数实现的分离

声明写在头文件里面，成员函数写在源代码 ``*.cpp`` 里面，别人在调用的时候使用源代码生成的静态库 ``*.lib`` 或者动态链接库 ``*.dll``，不能看到源代码。

---

## 9.2

构造函数

---

对象的初始化

1. 如果对象的成员都是共有的，直接按照结构体的方法初始化。但是如果存在私有成员就不能使用这种方法。
2. 或者写一个赋初值的共有成员函数，对成员进行初始化。
3. 或者声明对象的时候直接赋值，在 C++11 标准以后才可以，不能个性化。

---

为了避免上面三种方法的缺点，引入构造函数。

完成对象的初始化，对象建立时自动调用。

```cpp
class Time
{
    int hour, minute, sec;
    public:
        Time(int h, int m, int s)
        {
            hour = h;
            minute = m;
            sec = s;
        }
}
Time t1 (11, 11, 11); // implicit
Time t4 = Time(11, 11, 11); // explicit
Time t2 {11, 11, 11}; // implicit
Time t1={11, 11, 11}; // implicit
```

当然也可以体外实现。也可以采用初始化表的形式。

```cpp
Time(int h, int m, int s): hour(h), minute(m), sec(s)
{
}
```

构造函数必须是共有函数。缺省构造函数是无参数列表，函数实现为空的函数。

---

通过构造函数，可以实现对参数的范围判断。

构造函数可以重载

```cpp
Time::Time()
{
    hour = 0;
    minute = 0;
    sec = 0;
}
Time::Time(int h, int m, int s)
{
    hour = h;
    minute = m;
    sec = s;
}
```

---

## 9.3

析构函数

---

在对象生命周期结束的时候，析构函数进行一些善后。

缺省的析构函数是无参数列表，空函数体。

```cpp
Time::~Time()
{
    ;
}
```

析构函数没有参数，也不允许重载。不能被用户显示调用。

在没有动态内存申请的时候，一般不需要析构函数。

---

## 9.4

构造函数和析构函数的调用时刻

---

| 对象                 | 构造函数       | 析构函数 |
| :------------------: | :------------: | :------: |
| 自动对象             | 函数中变量定义 | 函数结束 |
| 静态局部对象         | 第一次定义     | 程序结束 |
| 静态全局或者外部全局 | 程序开始（早于 ``main``）       | 程序结束 |

---

## 9.5

对象数组

---

形式和基本类型数组一致。

初始化

```cpp
Time::Time(int h = 0, int m = 0, int s = 0)
{
    int hour = h;
    int min = m;
    int sec = s;
}
Time times[10] = {Time(1,2,3), Time(4,5), 6, 7, 8, 9};
Time times[10] = {{1,2,3}, {4,5}, 6, 7, 8, 9};
```

---

## 9.6

对象指针

---

定义形式和基本类型的指针相同。

访问数据和成员函数的方法也和结构体指针相同。

---

this pointer

```cpp
void Time::display()
{
    cout << hour << ":" << minute << ":" << second << endl;
}

void Time::display() // parameter: const Time * this
{
    cout << this->hour << ":" << this->minute << ":" << this->second << endl;
}
```

可以隐式使用成员，可以显式调用 ``this``，但是不能定义 ``this``.

---

## 9.7

对象的赋值和复制

---

对象的赋值：把 ``t1`` 的数据成员一一赋值给 ``t2``.

```cpp
Time t1(14, 15, 23), t2;
t2 = t1;
```

把一个对象的数据的整体的内存拷贝。当然不会拷贝成员函数。

---

对象的复制

```cpp
Time t1(14, 15, 23), t2(t1), t3 = t1;
```

复制在定义语句中，赋值在后面的语句中。

---

## 9.8

友元

---

如何在全局的空间中访问私有的数据成员？

经典方法：定义读和写这个数据的成员函数。效率太低。

引入友元（friend），允许友元访问私有数据。

友元不是面向对象的概念，破坏了数据的封装性，但是方便使用，效率高。

---

声明全局函数为友元函数。

```cpp
class Time
{
    private:
        int hour;
        int minute;
        int second;
        friend void display(Time &t);
    public:
        // ...
}
```

友元函数内部可以使用直接成员访问符来访问私有成员，因为不是类的成员函数，因此不能使用 ``this`` pointer.

---

声明其他类的成员函数为友元函数。

---

声明其他类为友元类。

- 提前声明
- 友元不可以传递：不能访问友元的友元
- 友元是单向的
- C++ 规定同一个类的不同对象互为友元
