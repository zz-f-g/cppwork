# Function

---

## 4.1

introduction

---

## 4.2

definition

---

无参函数

```
type func_name([void])
{
    ...;
    return ...;
}
```

缺省返回类型

- C: ``int`` by default
- CPP: error

---

有参函数

```
type func_name(type var1[, type var2...])
{
    ...;
    return ...;
}
```

---

## 4.3

parameters and value

---

Parameters

- formal parameter
- actual parameter

---

函数在执行时临时分配空间，在执行结束以后空间释放。

如果之后的函数执行，可能会占用之前的函数的空间。

---

如果返回类型和 ``return`` 的类型不一致，以返回类型为准。

---

如果 ``return`` 语句没有覆盖所有分支，Visual C++ 编译器会警告。

```cpp
int fun(int x)
{
    if (x>1)
        return 1;
    else if (x<=1)
        return 0;
}
```

虽然在事实上覆盖了所有分支，但是在形式上没有。因此也会产生警告。

---

```cpp
int fun()
{
    int i = 0;
    for (i=0; i<=100; i++)
    {
        if (i>=10)
            return 0;
    }
}
```

同理也会报错。

---

```cpp
int fun()
{
    int i = 0;
    for (i=0; ; i++)
    {
        if (i>=10)
            return 0;
    }
}
```

这样不会报错。因为此时程序只有唯一出口。

---

## 4.4

Calling of Function

---

对于多个形参的函数，不要传入同一实参，不同编译器的处理不同。

---

调用库函数

```c
#include <stdio.h>
#include <math.h>
#include <string.h>
```

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
```

---

函数声明

```
type func_name(type [var1, type var2, ...]);
```

---

## 4.5

函数的嵌套调用

---

C++ 程序的执行过程

1. 从 ``main`` 函数的第一个语句开始一次执行
2. 执行到函数调用语句，则保存调用函数当前的系统信息
3. 转到被调用函数的第一个执行语句开始执行
4. 被调用函数执行完成后，返回被调用函数的调用处，恢复调用前保存的系统信息
5. 如果被调用函数中仍有调用其他函数的语句，按照栈的规则嵌套执行上述步骤 2-4.
6. 所有被调用函数执行完成以后，回到 ``main`` 函数顺序执行。

---

## 4.6

递归

---

- 直接递归
- 间接递归

必然有条件判断是否进入下一次递归。

---

递归的求解过程

1. 回推：找到结果
2. 递推：从结果推回需要的

---

```cpp
void num_sys_convert(int n, int base)
{
    if (n >= base)
        num_sys_convert(n / base, base);
    cout << n % base;
    cout << endl;
}
```

---

## 4.7

以下为 CPP 特有。

内联函数

---

```cpp
inline int max(int x, int y)
{
    return (x >= y) ? x : y;
}
```

直接将函数中的语句插入调用函数的位置，在执行过程中**不存在调用栈的过程**。

因此使用 ``inline`` 可以用空间换取时间，避免了“保存和恢复现场”所花费的时间。

内联函数的写法是否编译成是真实的内联函数，这是由编译器决定的。

在内联函数中不能有复杂的分支、循环语句。

---

```cpp
#include <iostream>
using namespace std;
inline swap(int x, int y)
{
    int tmp = x;
    x = y;
    y = tmp;
}
int main()
{
    int x, y;
    x = 1;
    y = 0;
    cout << "x=" << x << ", y=" << y << endl; // x=1, y=0
    swap(x, y);
    cout << "x=" << x << ", y=" << y << endl; // x=1, y=0
    return 0;
}
```

---

不同的编译器对 ``inline`` 到底写在原型还是构造的位置的规定不同。

``inline`` 函数和调用函数必须写在同一个源程序文件中。普通函数可以不这样。

---

## 4.8

重载

---

定义：同一作用域内中的多个函数使用相同的函数名。

引入的原因：

1. 对不同类型的参数实现相同的功能，希望使用相同的函数名字
2. 对不同数量的参数实现相同的功能，希望使用相同的函数名字

上面两种情况，C++ 都允许，C 都不允许。

要求：同名的函数，参数的个数和类型不能完全相同

---

## 4.9

函数模板

---

对于参数个数，函数实现过程完全相同，仅有类型不同的函数，如果使用重载，仍然要写两遍。

引入：函数模板

```cpp
template <typename T> // 虚类型
T my_max(T x, T y)
{
    cout << sizeof(x) << ' ';
    return x > y ? x : y;
}
```

---

要求：参数个数相同，实现过程完全相同，仅有类型不同。

或者使用

```cpp
template <class T>
template <class T1, class T2>
```

---

## 4.10

默认参数

---

默认参数建议为常量。

如果在原型定义的时候如果定义了默认值参数，在 ``main()`` 函数之后的函数定义就不再需要定义默认值参数。**即使一样也会报错**。

重载和默认值参数仪器使用的时候，**可能**会产生**二义性**。

---

## 4.11

局部变量和全局变量

---

 - 局部变量：只在函数内部可以访问
 - 全局变量：从定义点到源程序文件结束都可以访问

---

复合语句内的变量仅在复合语句大括号内部有效，包括 ``while, for``，包括单走一个 ``{}``.

```cpp
int i;
for (i = 0; i < 10; ++i)
{
    int y; // 变量 y 总共分配了几次？
    y = i;
}
```

在第九章将有详细说明。

---

全局变量在某个函数中被改变以后，在所有的函数中访问得到的是被改变的结果。

---

## 4.12

变量的存储类别

---

内存划分

1. 程序指令区
2. 静态存储区
3. 动态存储区

---

局部变量的存储

- 自动变量：函数进入后分配变量，函数运行结束后释放空间（``auto`` 类型必须初始化）
- 静态局部变量：变量的存储单元在程序执行过程中均不释放，只一次赋初值

```cpp
#include <iostream>
using namespace std;
void f()
{
    static int a = 1;
    a++;
    cout << "a=" << a << endl;
}
int main()
{
    f(); // a = 1
    f(); // a = 2
    f(); // a = 3
    return 0;
}
```

静态局部变量不赋初值，默认为 0.

---

寄存器变量

对于一些频繁访问的变量，可以放入 CPU 寄存器中，提高访问速度。
```cpp
register int a;
```
如果寄存器**没空**，这个数据将被**抹除**，不能长期占有寄存器。

甚至即使定义了 ``register``，编译系统会自动判断，最终是否放入寄存器中，仍要由编译系统决定。

---

``extern``

扩大全局变量的使用范围，但在这个语句位置不分配空间。

一般用于多文件程序

```cpp
// file1.cpp
int a;
int main()
{
    a = 0;
    return 0;
}
```

```cpp
// file2.cpp
extern int a;
int main()
{
    // extern int a;
    a = 1; // ok
    return 0;
}
```

```cpp
// file3.cpp
static int a; // can't be called by other file
```

---

## 4.13

变量属性小结

---

- 生存期：什么时间存在
    - 动态存储
    - 静态存储
- 作用域：什么范围可以访问
    - 局部变量
    - 全局变量
- 链接性：**全局变量**如何在不同单元之间共享
    - 静态全局：只能在本源程序中访问
    - 外部全局：可以在多个源程序中访问

---

| 类型         | 生存期     | 作用域         | 存储区         |
| ------------ | ---------- | -------------- | -------------- |
| 自动变量     | 本函数     | 本函数         | 动态存储区     |
| 形式参数     | 本函数     | 本函数         | 动态存储去     |
| 寄存器变量   | 本函数     | 本函数         | 寄存器（可能） |
| 静态局部变量 | 程序执行中 | 本函数         | 静态存储区     |
| 静态全局变量 | 程序执行中 | 本源程序文件   | 静态存储区     |
| 外部全局变量 | 程序执行中 | 全部源程序文件 | 静态存储区     | 

---

## 4.14

变量的定义和声明

---

- 定义 ``int a;`` 指明变量类型并分配空间
- 声明 ``extern int a;`` 指明变量类型，不分配空间

---

## 4.15

内部函数和外部函数

---

- 内部函数：只能在本源程序文件中调用（不同的源程序文件之间可以同名） ``static int f();``
- 外部函数：可以在所有的源程序文件中调用（其他源程序文件中需要声明）``[extern] int f();``

---

## 4.16

头文件

---

头文件中间放函数，结构体类型和类的声明。

``#include "head.h"`` 相当于将头文件中的内容插入源程序中。

头文件还可以放：

- 常量
- 宏定义
- ``extern``

不能在头文件中初始化全局变量，否则会在多个源程序中重复定义。因此必须在一个源程序文件中定义全局变量，在头文件中使用 ``extern`` 声明。

头文件中可以定义初始化静态存储区中的变量（比如只读变量和静态变量），因为这些变量的生存期是所有的程序源文件。

头文件的作用：收集不同源文件需要的信息

---

头文件的导入方式

- ``<>`` 直接到系统目录中寻找，找不到则报错
- ``""`` 现在当前目录中寻找，找不到再到系统目录中寻找，都找不到才报错

```cpp
#pragma once // 避免重复包含
```

---

全局变量使用的原则：权限最小化原则

1. 尽量不用，使用实参形参传递数据
2. 如果必须使用全局变量，尽量使用静态全局变量
3. 在其他的源程序文件中使用 ``extern`` 声明
4. 命名规则：下划线开头（，下划线结尾）
